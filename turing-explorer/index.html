<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turing Pattern Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #fff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }

        canvas {
            display: block;
            width: 100%;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: crosshair;
        }

        .controls {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid rgba(255,255,255,0.3);
            padding-bottom: 5px;
        }

        .animal-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .animal-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            color: #fff;
            font-size: 1em;
            font-weight: 600;
        }

        .animal-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .animal-btn.active {
            background: rgba(255,255,255,0.4);
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76,175,80,0.5);
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .slider-value {
            float: right;
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .action-buttons {
            display: grid;
            gap: 10px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            padding: 12px;
            color: #fff;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        button:hover {
            transform: scale(1.05);
        }

        button:active {
            transform: scale(0.98);
        }

        .phase-diagram {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-top: 20px;
        }

        .phase-diagram h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        #phaseDiagram {
            display: block;
            width: 100%;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            background: #fff;
        }

        .info-box {
            background: rgba(255,255,255,0.1);
            border-left: 4px solid #4CAF50;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9em;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ü¶Å Turing Pattern Explorer</h1>
            <p class="subtitle">Reaction-Diffusion Simulation on Animal Silhouettes</p>
        </header>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
            </div>

            <div class="controls">
                <div class="control-group">
                    <h3>üêæ Select Animal</h3>
                    <div class="animal-grid">
                        <button class="animal-btn active" data-animal="leopard">üêÜ Leopard</button>
                        <button class="animal-btn" data-animal="zebra">ü¶ì Zebra</button>
                        <button class="animal-btn" data-animal="giraffe">ü¶í Giraffe</button>
                        <button class="animal-btn" data-animal="cheetah">üêÜ Cheetah</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>‚öôÔ∏è Parameters</h3>
                    <div class="slider-group">
                        <label>
                            Feed Rate
                            <span class="slider-value" id="feedValue">0.037</span>
                        </label>
                        <input type="range" id="feedRate" min="0.01" max="0.1" step="0.001" value="0.037">
                    </div>
                    <div class="slider-group">
                        <label>
                            Kill Rate
                            <span class="slider-value" id="killValue">0.060</span>
                        </label>
                        <input type="range" id="killRate" min="0.03" max="0.08" step="0.001" value="0.060">
                    </div>
                </div>

                <div class="control-group">
                    <h3>üéÆ Controls</h3>
                    <div class="action-buttons">
                        <button id="playPauseBtn" onclick="togglePlayPause()" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">‚ñ∂Ô∏è Play</button>
                    </div>
                </div>

                <div class="control-group">
                    <h3>üé® Presets</h3>
                    <div class="action-buttons">
                        <button onclick="applyPreset('spots')">Spots</button>
                        <button onclick="applyPreset('stripes')">Stripes</button>
                        <button onclick="applyPreset('mixed')">Mixed</button>
                        <button onclick="resetSimulation()">Reset</button>
                    </div>
                </div>

                <div class="info-box">
                    üí° <strong>Tip:</strong> Click on the canvas to add chemical B and watch patterns emerge!
                </div>
            </div>
        </div>

        <div class="phase-diagram">
            <h3>üìä Phase Space Diagram</h3>
            <canvas id="phaseDiagram"></canvas>
            <div class="info-box">
                The phase diagram shows different pattern regimes. Your current parameters are marked with a red dot.
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const config = {
            width: 600,
            height: 600,
            dA: 1.0,    // Diffusion rate of chemical A
            dB: 0.35,   // Reduced for finer patterns
            feed: 0.037,  // Default to spots pattern
            kill: 0.060,
            dt: 1.0
        };

        // Natural color schemes for each animal
        const animalColors = {
            leopard: {
                base: { r: 210, g: 170, b: 100 },  // Golden tan
                pattern: { r: 80, g: 50, b: 20 }    // Dark brown
            },
            zebra: {
                base: { r: 240, g: 240, b: 240 },   // White
                pattern: { r: 20, g: 20, b: 20 }    // Black
            },
            giraffe: {
                base: { r: 200, g: 160, b: 100 },   // Light tan
                pattern: { r: 100, g: 70, b: 40 }   // Brown
            },
            cheetah: {
                base: { r: 220, g: 180, b: 110 },   // Light tan
                pattern: { r: 40, g: 30, b: 20 }    // Very dark brown/black
            }
        };

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = config.width;
        canvas.height = config.height;

        const phaseCanvas = document.getElementById('phaseDiagram');
        const phaseCtx = phaseCanvas.getContext('2d');
        phaseCanvas.width = 400;
        phaseCanvas.height = 400;

        // Simulation grids
        let grid, next;
        let mask;
        let currentAnimal = 'leopard';
        let isPlaying = false;  // Start paused
        let animationId = null;

        // Initialize grids
        function initGrids() {
            grid = Array(config.width).fill(null).map(() =>
                Array(config.height).fill(null).map(() => ({
                    a: 1,
                    b: 0
                }))
            );
            next = Array(config.width).fill(null).map(() =>
                Array(config.height).fill(null).map(() => ({
                    a: 1,
                    b: 0
                }))
            );
        }

        // Emoji for each animal
        const animalEmoji = {
            leopard: 'üêÜ',
            zebra: 'ü¶ì',
            giraffe: 'ü¶í',
            cheetah: 'üêÖ'
        };

        // Animal silhouette functions using emoji
        function createMask(animal) {
            const mask = Array(config.width).fill(null).map(() =>
                Array(config.height).fill(false)
            );

            // Create temporary canvas for emoji rendering
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = config.width;
            tempCanvas.height = config.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Clear canvas
            tempCtx.clearRect(0, 0, config.width, config.height);

            // Get emoji for the animal
            const emoji = animalEmoji[animal];

            // Set up text rendering for emoji
            const emojiSize = 400; // Large emoji
            tempCtx.font = `${emojiSize}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';

            // Draw emoji in center
            tempCtx.fillText(emoji, config.width / 2, config.height / 2);

            // Read pixel data to create mask
            const imageData = tempCtx.getImageData(0, 0, config.width, config.height);
            const data = imageData.data;

            for (let x = 0; x < config.width; x++) {
                for (let y = 0; y < config.height; y++) {
                    const idx = (y * config.width + x) * 4;
                    // If pixel is not transparent (alpha > 10), it's part of the animal
                    if (data[idx + 3] > 10) {
                        mask[x][y] = true;
                    }
                }
            }

            return mask;
        }

        // Gray-Scott reaction-diffusion algorithm
        function laplacian(grid, x, y) {
            let a = 0, b = 0;

            // 9-point stencil for better accuracy
            const weights = [
                [0.05, 0.2, 0.05],
                [0.2, -1.0, 0.2],
                [0.05, 0.2, 0.05]
            ];

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const nx = (x + i + config.width) % config.width;
                    const ny = (y + j + config.height) % config.height;
                    a += grid[nx][ny].a * weights[i + 1][j + 1];
                    b += grid[nx][ny].b * weights[i + 1][j + 1];
                }
            }

            return { a, b };
        }

        function update() {
            for (let x = 1; x < config.width - 1; x++) {
                for (let y = 1; y < config.height - 1; y++) {
                    if (!mask[x][y]) {
                        next[x][y].a = 0;
                        next[x][y].b = 0;
                        continue;
                    }

                    const cell = grid[x][y];
                    const lap = laplacian(grid, x, y);

                    const abb = cell.a * cell.b * cell.b;

                    next[x][y].a = cell.a +
                        (config.dA * lap.a - abb + config.feed * (1 - cell.a)) * config.dt;
                    next[x][y].b = cell.b +
                        (config.dB * lap.b + abb - (config.kill + config.feed) * cell.b) * config.dt;

                    // Clamp values
                    next[x][y].a = Math.max(0, Math.min(1, next[x][y].a));
                    next[x][y].b = Math.max(0, Math.min(1, next[x][y].b));
                }
            }

            [grid, next] = [next, grid];
        }

        function render() {
            const imageData = ctx.createImageData(config.width, config.height);
            const data = imageData.data;

            // Get color scheme for current animal
            const colors = animalColors[currentAnimal];

            for (let x = 0; x < config.width; x++) {
                for (let y = 0; y < config.height; y++) {
                    const idx = (y * config.width + x) * 4;

                    if (!mask[x][y]) {
                        data[idx] = 240;
                        data[idx + 1] = 240;
                        data[idx + 2] = 240;
                        data[idx + 3] = 255;
                    } else {
                        const a = grid[x][y].a;
                        const b = grid[x][y].b;

                        // Smooth gradient between base color and pattern color
                        // Higher B concentration = more pattern color (spots/stripes)
                        const concentration = Math.pow(b, 0.6); // Power for smoother transition

                        // Interpolate between base and pattern colors
                        const r = colors.base.r + (colors.pattern.r - colors.base.r) * concentration;
                        const g = colors.base.g + (colors.pattern.g - colors.base.g) * concentration;
                        const bl = colors.base.b + (colors.pattern.b - colors.base.b) * concentration;

                        data[idx] = Math.floor(r);
                        data[idx + 1] = Math.floor(g);
                        data[idx + 2] = Math.floor(bl);
                        data[idx + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw outline around the animal
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();

            for (let x = 1; x < config.width - 1; x++) {
                for (let y = 1; y < config.height - 1; y++) {
                    if (mask[x][y]) {
                        // Check if any neighboring pixel is outside the mask (edge detection)
                        const isEdge = !mask[x-1][y] || !mask[x+1][y] ||
                                      !mask[x][y-1] || !mask[x][y+1];

                        if (isEdge) {
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
        }

        // Phase diagram
        function drawPhaseDiagram() {
            const w = phaseCanvas.width;
            const h = phaseCanvas.height;

            // Clear
            phaseCtx.fillStyle = '#f0f0f0';
            phaseCtx.fillRect(0, 0, w, h);

            // Draw regions (approximate)
            phaseCtx.font = '14px sans-serif';

            // Spots region
            phaseCtx.fillStyle = 'rgba(255, 200, 100, 0.3)';
            phaseCtx.fillRect(w * 0.3, h * 0.2, w * 0.4, h * 0.3);
            phaseCtx.fillStyle = '#333';
            phaseCtx.fillText('Spots', w * 0.45, h * 0.35);

            // Stripes region
            phaseCtx.fillStyle = 'rgba(100, 200, 255, 0.3)';
            phaseCtx.fillRect(w * 0.2, h * 0.5, w * 0.5, h * 0.3);
            phaseCtx.fillStyle = '#333';
            phaseCtx.fillText('Stripes', w * 0.4, h * 0.65);

            // Mixed patterns
            phaseCtx.fillStyle = 'rgba(200, 100, 255, 0.3)';
            phaseCtx.fillRect(w * 0.5, h * 0.3, w * 0.3, h * 0.4);
            phaseCtx.fillStyle = '#333';
            phaseCtx.fillText('Mixed', w * 0.6, h * 0.5);

            // Axes
            phaseCtx.strokeStyle = '#333';
            phaseCtx.lineWidth = 2;
            phaseCtx.beginPath();
            phaseCtx.moveTo(50, h - 50);
            phaseCtx.lineTo(w - 20, h - 50);
            phaseCtx.moveTo(50, h - 50);
            phaseCtx.lineTo(50, 20);
            phaseCtx.stroke();

            // Labels
            phaseCtx.fillStyle = '#333';
            phaseCtx.font = '12px sans-serif';
            phaseCtx.fillText('Feed Rate', w / 2 - 30, h - 10);
            phaseCtx.save();
            phaseCtx.translate(15, h / 2);
            phaseCtx.rotate(-Math.PI / 2);
            phaseCtx.fillText('Kill Rate', -30, 0);
            phaseCtx.restore();

            // Current position
            const feedNorm = (config.feed - 0.01) / (0.1 - 0.01);
            const killNorm = (config.kill - 0.03) / (0.08 - 0.03);
            const px = 50 + feedNorm * (w - 70);
            const py = (h - 50) - killNorm * (h - 70);

            phaseCtx.fillStyle = 'red';
            phaseCtx.beginPath();
            phaseCtx.arc(px, py, 6, 0, Math.PI * 2);
            phaseCtx.fill();
            phaseCtx.strokeStyle = 'white';
            phaseCtx.lineWidth = 2;
            phaseCtx.stroke();
        }

        // Seed initial patterns
        function seedPattern() {
            // Create more random, smaller seeds for finer patterns
            for (let i = 0; i < 80; i++) {
                const x = Math.floor(Math.random() * config.width);
                const y = Math.floor(Math.random() * config.height);

                // Smaller seed radius for finer patterns
                const seedRadius = 2;

                for (let dx = -seedRadius; dx <= seedRadius; dx++) {
                    for (let dy = -seedRadius; dy <= seedRadius; dy++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < config.width && ny >= 0 && ny < config.height) {
                            if (mask[nx][ny] && dx * dx + dy * dy <= seedRadius * seedRadius) {
                                grid[nx][ny].b = 0.5 + Math.random() * 0.5; // Varied concentration
                            }
                        }
                    }
                }
            }
        }

        // Reset simulation
        function resetSimulation() {
            initGrids();
            mask = createMask(currentAnimal);
            seedPattern();
            render();
        }

        // Preset patterns
        function applyPreset(type) {
            switch(type) {
                case 'spots':
                    config.feed = 0.037;  // Fine-tuned for smaller, more natural spots
                    config.kill = 0.060;
                    break;
                case 'stripes':
                    config.feed = 0.029;  // Fine-tuned for cleaner stripes
                    config.kill = 0.057;
                    break;
                case 'mixed':
                    config.feed = 0.034;  // Fine-tuned for intricate mixed patterns
                    config.kill = 0.056;
                    break;
            }
            document.getElementById('feedRate').value = config.feed;
            document.getElementById('killRate').value = config.kill;
            document.getElementById('feedValue').textContent = config.feed.toFixed(3);
            document.getElementById('killValue').textContent = config.kill.toFixed(3);
            drawPhaseDiagram();
            resetSimulation();
        }

        // Event listeners
        document.querySelectorAll('.animal-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.animal-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentAnimal = this.dataset.animal;
                resetSimulation();
            });
        });

        document.getElementById('feedRate').addEventListener('input', function() {
            config.feed = parseFloat(this.value);
            document.getElementById('feedValue').textContent = config.feed.toFixed(3);
            drawPhaseDiagram();
        });

        document.getElementById('killRate').addEventListener('input', function() {
            config.kill = parseFloat(this.value);
            document.getElementById('killValue').textContent = config.kill.toFixed(3);
            drawPhaseDiagram();
        });

        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * (config.width / rect.width));
            const y = Math.floor((e.clientY - rect.top) * (config.height / rect.height));

            for (let dx = -10; dx <= 10; dx++) {
                for (let dy = -10; dy <= 10; dy++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < config.width && ny >= 0 && ny < config.height) {
                        if (mask[nx][ny] && dx * dx + dy * dy < 100) {
                            grid[nx][ny].b = 1;
                        }
                    }
                }
            }
        });

        // Play/Pause control
        function togglePlayPause() {
            isPlaying = !isPlaying;
            const btn = document.getElementById('playPauseBtn');

            if (isPlaying) {
                btn.innerHTML = '‚è∏Ô∏è Pause';
                btn.style.background = 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)';
                animate();
            } else {
                btn.innerHTML = '‚ñ∂Ô∏è Play';
                btn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
            }
        }

        // Animation loop
        function animate() {
            if (!isPlaying) return;

            for (let i = 0; i < 10; i++) {
                update();
            }
            render();
            animationId = requestAnimationFrame(animate);
        }

        // Initialize
        initGrids();
        mask = createMask(currentAnimal);
        seedPattern();
        drawPhaseDiagram();
        render(); // Draw initial state without animating
    </script>
</body>
</html>
